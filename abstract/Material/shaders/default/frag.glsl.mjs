export default "varying vec3 v_normal;\n\n#ifdef USES_BUMP_MAP\nvarying vec3 v_view_position;\n#endif\n\n// TODO had to move this to the top of builtins...\n// need a better approach\n\n// #ifdef USES_TEXTURES\n// varying vec2 v_uv;\n// #endif\n\nvarying vec3 v_surface_to_light[NUM_LIGHTS];\nvarying vec3 v_surface_to_view[NUM_LIGHTS];\n\nvoid main () {\n\tvec3 normal = normalize(v_normal);\n\n\t#ifdef USES_BUMP_MAP\n\tnormal = perturbNormalArb(-v_view_position, normal, dHdxy_fwd());\n\t#endif\n\n\tvec3 lighting = vec3(0.0);\n\tvec3 specularity = vec3(0.0);\n\n\t// directional lights\n\tfor (int i = 0; i < NUM_LIGHTS; i += 1) {\n\t\tDirectionalLight light = DIRECTIONAL_LIGHTS[i];\n\n\t\tfloat multiplier = clamp(dot(normal, -light.direction), 0.0, 1.0);\n\t\tlighting += multiplier * light.color * light.intensity;\n\t}\n\n\t// point lights\n\tfor (int i = 0; i < NUM_LIGHTS; i += 1) {\n\t\tPointLight light = POINT_LIGHTS[i];\n\n\t\tvec3 surface_to_light = normalize(v_surface_to_light[i]);\n\n\t\tfloat multiplier = clamp(dot(normal, surface_to_light), 0.0, 1.0); // TODO is clamp necessary?\n\t\tlighting += multiplier * light.color * light.intensity;\n\n\t\tvec3 surface_to_view = normalize(v_surface_to_view[i]);\n\t\tvec3 half_vector = normalize(surface_to_light + surface_to_view);\n\t\tfloat spec = clamp(dot(normal, half_vector), 0.0, 1.0);\n\n\t\t#ifdef USES_SPEC_MAP\n\t\tspec *= texture2D(SPEC_MAP, v_uv).r;\n\t\t#endif\n\n\t\tspecularity += spec * light.color * light.intensity;\n\t}\n\n\t// temp\n\t#ifdef USES_BUMP_MAP\n\t\tgl_FragColor = vec4(normal, 1.0);\n\t#else\n\t\t#ifdef USES_COLOR_MAP\n\t\tvec4 color = texture2D(COLOR_MAP, v_uv);\n\t\t#else\n\t\tvec4 color = vec4(COLOR, 1.0);\n\t\t#endif\n\n\t\tgl_FragColor = color;\n\n\t\t#ifdef USES_ALPHA\n\t\tgl_FragColor.a = ALPHA;\n\t\t#endif\n\n\t\tgl_FragColor.rgb *= mix(AMBIENT_LIGHT, vec3(1.0, 1.0, 1.0), lighting);\n\t\tgl_FragColor.rgb += specularity;\n\t#endif\n}";